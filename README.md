# 视触觉传感器标记点识别：光场仿真与自适应算法原理全解

本指南旨在为视触觉传感器（Vision-based Tactile Sensors, e.g., GelSight）的研发提供完整的理论支持与仿真验证说明。文档涵盖了从**物理背景**、**数学原理**到**代码实现**的全链路解析。

---

## 1. 研究背景与科学挑战

### 1.1 视触觉传感器的工况
视触觉传感器通常由一层涂有反光涂层（或嵌入标记点）的弹性体、透明支撑板、摄像头以及照明系统组成。本仿真模拟了一个**底面为 40x40mm 正方形**、**高度为 30mm** 的传感器结构，表面分布着 **10x10 的标记点阵列**。其核心原理是通过摄像头捕捉弹性体表面的形变（三维重构）或标记点的位移（力场计算）。

### 1.2 核心挑战：非均匀光场 (Non-uniform Illumination)
由于空间限制，光源（通常为 LED 阵列）必须安装在弹性体的侧面或边缘。这种**侧向照明 (Side Illumination)** 几何结构导致了无法避免的光学现象：
1.  **中心-边缘差异**：光线传播距离不同，导致中心区域亮度远高于边缘。
2.  **方向性衰减**：LED 作为朗伯辐射体，其发光强度随角度急剧衰减。

**结果**：传感器图像呈现出剧烈的动态范围变化（Dynamic Range Variation）。同一个黑色的标记点，在亮区的像素值可能为 100（灰），而在暗区的像素值可能为 20（黑）。**传统的全局固定阈值（Global Thresholding）无法同时在亮区和暗区有效提取标记点。**

---

## 2. 物理与数学原理

### 2.1 光照场物理模型
本仿真采用了经典的**朗伯辐射模型 (Lambertian Model)** 来描述 LED 的发光特性。

对于空间中任意一点 $P$，其接收到的光强 $E$ 由以下公式决定：

$$
E(P) = \sum_{i=1}^{N} \frac{I_0 \cdot \cos^m(\theta_i)}{d_i^2} \cdot \cos(\alpha_i)
$$

*   **$d_i$ (距离衰减)**：遵循平方反比定律 ($1/d^2$)，是造成光照不均的主要因素。
*   **$\cos^m(\theta_i)$ (光源方向性)**：LED 不是各向同性光源。$m$ 值由半功率角 (FOV) 决定：$m = \frac{-\ln 2}{\ln(\cos(\text{FOV}/2))}$。FOV 越小，光束越集中，$m$ 越大。
*   **叠加原理**：最终光场是所有 $N$ 个 LED 贡献的线性叠加。

### 2.2 图像成像模型
相机采集到的图像 $I(x,y)$ 可视为**光照分量**、**反射率分量**与**随机噪声**的综合作用：

$$
I(x,y) = \text{clip}(L(x,y) \cdot R(x,y) + N(x,y), 0, 255)
$$

*   **$L(x,y)$ - 光照分量 (Illumination)**：主要由光源分布决定，变化平缓，属于**低频信息**。
*   **$R(x,y)$ - 反射率分量 (Reflectance)**：由表面材质（背景/标记点）决定，变化剧烈，属于**高频信息**。
*   **$N(x,y)$ - 随机噪声 (Noise)**：由传感器热噪声、散粒噪声等引起。仿真中采用高斯白噪声模型：$N \sim \mathcal{N}(0, \sigma^2)$。

### 2.3 全局阈值算法原理 (Otsu's Method)
作为对比，本仿真也实现了经典的 Otsu 全局阈值法。其核心思想是寻找一个全局唯一的阈值 $T$，使得分割后的前景和背景的**类间方差 (Inter-class Variance)** 最大。

假设图像灰度级为 $L$，对于任意阈值 $t$，前景和背景的像素占比分别为 $\omega_0(t), \omega_1(t)$，平均灰度分别为 $\mu_0(t), \mu_1(t)$，则类间方差定义为：

$$
\sigma_B^2(t) = \omega_0(t) \omega_1(t) [\mu_0(t) - \mu_1(t)]^2
$$

Otsu 算法通过遍历所有可能的 $t$ 值来最大化 $\sigma_B^2(t)$：

$$
T^* = \mathop{\arg\max}_{0 \le t < L} \sigma_B^2(t)
$$

**局限性**：Otsu 算法假设整张图像具有统一的光照背景。在视触觉传感器中，由于光照不均，中心亮区的背景灰度可能高于边缘暗区的背景灰度，导致无法找到一个单一的 $T$ 值能同时正确分割所有区域。

### 2.4 自适应阈值算法原理
为了提取标记点（即 $R(x,y)$ 中的突变），我们需要消除 $L(x,y)$ 的影响。自适应阈值算法本质上是一种**背景估计与差分**方法：

1.  **背景估计**：利用低通滤波器（高斯模糊）从原图中提取出光照分量 $\hat{L}(x,y)$。

$$
\hat{L}(x,y) = G_\sigma(x,y) * I(x,y)
$$

2.  **局部二值化**：将原图与估计背景进行比较。

$$
B(x,y) = \begin{cases} 255 & \text{if } I(x,y) < \hat{L}(x,y) - C \\ 0 & \text{otherwise} \end{cases}
$$

其中 $C$ 是为了抵抗噪声而引入的**对比度容限**。只有当某点的亮度显著低于其局部背景时，才被判定为标记点。

---

## 3. 代码实现与深度解读

项目包含三个核心仿真脚本：
1.  `simulation.py`：**单色白光仿真**，侧重于验证标记点提取算法。
2.  `simulation_rgb.py`：**RGB 3D 形变仿真**，侧重于验证光度立体视觉与物理光照模型。
3.  `light_distribution_viz.py`：**光路设计辅助工具**，侧重于硬件参数选型。

### 3.1 单色白光仿真 (`simulation.py`)

此文件将上述理论转化为可执行的数字孪生系统。

### 3.1.1 光场生成模块 (`generate_light_field`)

此函数模拟了物理光照模型和成像过程。

*   **LED 几何解算**：
    代码首先计算每个像素点相对于每个 LED 的距离向量 `dist` 和入射角度 `cos_theta`。
    ```python
    # 朗伯体指数 m 的计算 (对应原理 2.1)
    m = -np.log(2) / np.log(np.cos(alpha))
    # 光强叠加 (对应原理 2.1)
    intensity = self.led_power * (cos_theta ** m) / dist_sq
    ```

*   **材料属性模拟**：
    为了模拟真实的物理响应，代码引入了反射率参数，而不是简单的黑白二值。
    ```python
    # 背景设为高反射率 (如硅胶)
    img_temp = np.full(..., self.bg_reflectivity, ...) 
    # 标记点设为低反射率 (如油墨，非纯黑)
    cv2.circle(..., self.marker_reflectivity, ...)
    ```
    *意义*：这使得仿真能够测试算法在“低对比度”极端工况下的鲁棒性。

### 3.1.2 算法处理模块 (`calculate_adaptive_threshold`)

此函数实现了 2.3 节所述的数学逻辑。

*   **步骤 1：低通滤波 (背景估计)**
    ```python
    # block_size 决定了滤波器的截止频率
    mean_map = cv2.GaussianBlur(self.raw_image_norm, (self.block_size, self.block_size), 0)
    ```
    *解读*：这里得到的 `mean_map` 就是对光照分量 $L(x,y)$ 的数值近似。

*   **步骤 2：阈值面构建**
    ```python
    # 构建空间变化的阈值曲面
    self.threshold_map = mean_map - self.C
    ```
    *解读*：这一步生成了一个随光照起伏的“浮动基准面”。

*   **步骤 3：信号提取**
    ```python
    # 逻辑判断：信号是否“沉”到了基准面以下？
    self.binary_map[self.raw_image_norm < self.threshold_map] = 255
    ```

### 3.2 RGB 3D 形变仿真 (`simulation_rgb.py`)

在视触觉传感器（如 GelSight）的进阶应用中，常使用红、绿、蓝（RGB）三色 LED 从不同方向照射。这种设计不仅可以提取颜色信息，更可以通过**彩色光度立体视觉 (Photometric Stereo)** 恢复物体的三维形变。

#### 3.2.1 3D 几何与形变模型 (PDMS 物理增强版)

本脚本引入了基于 **PDMS (聚二甲基硅氧烷)** 物理特性的**连续形变场**模型，而非简单的几何布尔运算。

1.  **连续高度场 ($Z$)**：为了模拟弹性体的连续性（Continuity）和泊松效应（Poisson Effect），代码采用了**高斯平滑 (Gaussian Smoothing)** 技术。
    *   当球体压入时，形变不仅仅局限于接触区域。
    *   应力会通过弹性体向四周传播，导致非接触区域也产生微小的表面沉降。
    *   公式逻辑：$Z_{final} = \text{GaussianFilter}(Z_{geometric}, \sigma)$，其中 $\sigma$ 模拟了弹性体的硬度与形变传播范围。

2.  **微量畸变校准**：根据 PDMS 的高泊松比（~0.5）特性，标记点的位移和拉伸被校准为**微量形变**。
    *   避免了早期仿真中“标记点被夸张拉伸成细长椭圆”的失真现象。
    *   标记点现在会随表面梯度的变化产生微妙的向心位移和轻微的面积缩放，视觉效果更接近真实实验数据。

#### 3.2.2 高密度标记点阵列

为了更细腻地捕捉形变特征，脚本支持**动态调整标记点密度**。在 `main` 函数中，您可以轻松将传统的 10x10 阵列升级为更稠密的点阵：

```python
# 轻松调整标记点规模
sim_rgb.marker_row = 15  # 行数
sim_rgb.marker_col = 15  # 列数 (总计 225 个标记点)
```

#### 3.2.3 纯 RGB 光照物理仿真 (`simulation_result_rgb_sphere.png`)

本仿真严格遵循物理光照模型，**移除了所有人工合成的环境光 (Artificial Ambient Light)**。

*   **纯 LED 照明**：场景中的每一颗光子都源自 9 颗高功率 RGB LED。
*   **自然背景色**：
    *   图像背景的灰白色并非人为填充，而是红、绿、蓝三色光在平面中心自然叠加混合的结果。
    *   这解释了为何背景并非绝对均匀——它反映了真实的 LED 光场分布（中间亮、四周暗）。
*   **1. Simulated RGB Image**：展示了在球体压入下的彩色成像。由于光照模型的改进，色彩饱和度和对比度大幅提升，清晰地呈现出法向量变化带来的颜色梯度。
*   **2. RGB Light Field**：展示了 R-G-B 三色光源叠加后的全局光照场。
*   **3. 3D Geometry & LED Layout**：实时渲染的 3D 视图，展示了**连续形变后的 PDMS 表面**、LED 空间位置以及两者之间的几何关系。

### 3.3 光照分布可视化工具 (`light_distribution_viz.py`)

在实际硬件设计中，如何选择 LED 的高度 ($H$) 和视场角 (FOV) 是一个难题。此脚本专门用于**验证光路设计的合理性**。

#### 3.3.1 光锥投影与覆盖率分析

*   **光锥边界 (Cone Boundaries)**：脚本会计算每个 LED 在底面上的投射半径 $R_{cone} = H \cdot \tan(\text{FOV}/2)$，并用青色虚线圆绘制出每个 LED 的有效照明区域。
*   **设计验证**：
    *   通过观察虚线圆是否完全覆盖了中间的传感器区域 (40x40mm 正方形)，可以直观判断是否存在**照明盲区**。
    *   如果光锥未能覆盖底面四角，说明需要**增加 LED 高度**或**增大 FOV**。

#### 3.3.2 2D 光强热力图

*   脚本使用 `magma` 色图绘制了底面的光强分布。
*   **用途**：帮助工程师评估光照均匀度。如果中心过亮而边缘过暗，可能需要调整 LED 的径向距离或改变 LED 的排列密度。

---

## 4. 关键参数调优指南

基于上述原理，各参数的物理意义及调整策略如下：

| 参数 | 对应原理 | 调整建议 |
| :--- | :--- | :--- |
| **`block_size`** | **空间频率截断** | **核心参数**。必须大于标记点的物理尺寸，但小于光照变化的尺度。<br>• **过小**：滤波器会把标记点也当成背景的一部分，导致阈值面“塌陷”进标记点，造成漏检（中心空洞）。<br>• **建议**：设置为标记点直径像素数的 3-5 倍。<br>**截止频率计算**：$f_c \approx \frac{1}{\pi \cdot \text{block\_size}}$ (cycles/pixel)，对应的物理截止尺度 $\lambda_c \approx \pi \cdot \text{block\_size} \cdot \text{resolution}$。凡是尺寸小于 $\lambda_c$ 的物体都会被保留。 |
| **`C`** | **信噪比 (SNR)** | **灵敏度控制**。定义了信号必须强于背景噪声多少才能被检出。<br>• **过小**：会把传感器的随机噪声误判为标记点（椒盐噪声）。<br>• **过大**：会丢失对比度较弱（处于暗区或磨损）的标记点。 |
| **`noise_sigma`** | **随机噪声强度** | 模拟传感器本身的质量。<br>• **较大值**：模拟廉价或高增益下的传感器，测试算法的去噪性能。 |
| **`led_fov`** | **光源方向性** | 控制光场的均匀度。<br>• **FOV 小**：光斑集中，中心极亮，边缘极暗，对算法挑战最大。<br>• **FOV 大**：光照更均匀，但整体亮度可能下降。 |
| **`num_leds`** | **光源数量** | 决定了光场的叠加平滑度。<br>• **数量多**：光场更均匀，阴影更少。<br>• **数量少**：可能产生明显的多重阴影或暗区。 |
| **`width/height`** | **传感器几何** | 决定了光线传播的距离和角度范围。<br>• **高厚度**：光线衰减更严重，但中心区域可能更均匀。<br>• **大底面**：边缘区域可能非常暗。 |

---

## 5. 仿真结果深度解读 (Visualization Interpretation)

运行程序后生成的图表是评估算法性能的核心依据，以下是逐图解读指南：

### 5.1 图一：自适应算法过程分析 (`simulation_result_2d.png`)
这张图展示了算法处理的四个关键阶段：

*   **1. Simulated Raw Image (原始光场模拟)**
    *   **内容**：模拟相机拍摄到的原始灰度图。
    *   **观察重点**：注意**光照的不均匀性**。中心区域（LED光束交汇处）通常最亮，而边缘区域较暗。标记点在暗处的对比度显著低于亮处。
    *   **正常现象**：呈现“中间亮、四周暗”的渐变效果，标记点清晰可见。

*   **2. Adaptive Threshold Surface (阈值曲面)**
    *   **内容**：算法计算出的“浮动基准面” $T(x,y)$。
    *   **观察重点**：它应该是一张**平滑的**光照分布图，不应包含具体的标记点细节。
    *   **异常诊断**：如果图中有黑色的斑点（即标记点的影子），说明 `block_size` 设置过小，导致背景估计被标记点污染。

*   **3. Binary Result (二值化结果)**
    *   **内容**：最终提取的标记点掩膜。标题显示了提取到的标记点总数（例如 `Extracted Markers: 100`）。
    *   **观察重点**：
        *   **一致性**：最外圈（最暗处）的标记点是否被完整提取？
        *   **噪声**：背景中是否有随机白点？（若有，说明 `C` 设置过小）
        *   **粘连**：标记点是否独立？（若粘连，说明 `resolution` 不够或 `C` 过大）

*   **4. Cross Section Analysis (截面波形分析)**
    *   **内容**：沿中心轴线 ($y \approx 0$) 截取的信号波形图。这是**最科学的调试工具**。
    *   **图例说明**：
        *   **黑色实线 (Raw Signal)**：原始图像的灰度起伏。波峰是背景，波谷是标记点。
        *   **红色虚线 (Threshold)**：自适应阈值线。
    *   **判定标准**：**“包络与切割”**。红色虚线必须像信封一样紧贴黑色波峰的下方（包络背景），同时必须深深地切入每一个黑色波谷（切割标记点）。
    *   **调试技巧**：
        *   若红线切不到波谷 $\rightarrow$ 漏检 $\rightarrow$ 减小 `C`。
        *   若红线低于波峰太多 $\rightarrow$ 误检 $\rightarrow$ 增大 `C`。

### 5.2 图二：3D 空间模型 (`simulation_result_3d.png`)

*   **1. 3D Sensor Model (传感器几何)**
    *   **内容**：展示了 LED 的空间分布（橙色点）及其发射的光锥（黄色线）。
    *   **用途**：验证物理设计。检查光锥是否覆盖了整个底面？是否有明显的照明盲区？

*   **2. Intensity vs Threshold (光强拓扑)**
    *   **内容**：光照强度（彩色曲面）与阈值面（红色半透明曲面）的 3D 叠加。
    *   **用途**：直观感受光场的“陡峭”程度。如果曲面过于陡峭，说明光照极不均匀，对摄像头的动态范围要求很高。

### 5.3 图三：算法对比 (Simulation Comparison)
这张图直观展示了为什么必须使用自适应算法，而非简单的全局阈值。

*   **1. Ideal Uniform Light (Ground Truth)**
    *   **内容**：假设光照完美均匀时的理想图像。
    *   **用途**：作为“参考答案”。这里展示了最清晰的 10x10 标记点阵列，是我们期望得到的最佳效果。

*   **2. Simulated Input (Uneven Light)**
    *   **内容**：实际输入算法的、带有光照不均的图像（同图一的 Raw Image）。
    *   **对比点**：注意边缘区域的黑暗程度，这使得边缘标记点极难被检测。

*   **3. Otsu Global Threshold (Compromise)**
    *   **内容**：使用经典的 Otsu 算法计算全局唯一阈值（T）得到的结果。
    *   **典型失效模式**：
        *   **中心空洞**：为了照顾边缘的暗点，阈值设得太低，导致中心亮区的标记点（对比度不够深）被漏检。
        *   **边缘噪声**：为了照顾中心亮区，阈值设得太高，导致边缘的暗背景（低于阈值）直接被误判为标记点，形成一圈白色的“噪声墙”。
    *   **结论**：全局阈值法无法兼顾亮区和暗区。

*   **4. Adaptive Thresholding (Our Method)**
    *   **内容**：本仿真实现的自适应算法结果。
    *   **优势**：无论在中心的强光区，还是边缘的弱光区，标记点都能被清晰、独立地提取出来，且没有背景噪声。这证明了算法对非均匀光场的**鲁棒性**。

---

## 6. 双摄像头布局仿真 (Dual Camera Layout)

随着视触觉传感器向多模态发展，集成 RGB 摄像头（用于视觉纹理）和热成像摄像头（用于温度感知）成为一种趋势。`dual_camera_layout_sim_3d_flip.py` 脚本专门用于解决双摄像头在有限空间内的布局优化与光照遮挡问题。

### 6.1 仿真目标
在 40x40mm 的有限截面内，合理放置：
1.  **RGB 摄像头** (8.5x8.5mm, FOV 120°)
2.  **热成像摄像头** (Radius 5mm, FOV 110°)
3.  **9 颗 LED** (环形分布)

目标是实现：
*   **零物理干涉**：摄像头之间、摄像头与 LED 之间无碰撞。
*   **最小化光照遮挡**：摄像头实体不应阻挡 LED 照射到触觉表面的光路。
*   **最大化视野覆盖**：两个摄像头的 FOV 应尽可能覆盖触觉中心区域。

### 6.2 坐标系定义 (Flipped System)
为了符合物理安装逻辑（摄像头通常安装在传感器顶部 PCB 上，向下拍摄），本仿真采用了**翻转坐标系**：
*   **Z = 30mm (Sensor Depth)**: 顶部平面，放置 PCB、LED 和摄像头镜头。
*   **Z = 0mm**: 底部触觉平面（弹性体表面）。
*   **光路方向**: 从顶部 (Z=30) 射向底部 (Z=0)。

### 6.3 关键算法
*   **布局优化**: 采用对角线对称分布策略，自动计算两个摄像头的最小安全距离。
*   **3D 遮挡检测 (Ray Casting)**: 将摄像头建模为 3D 实体（圆柱体/长方体），通过计算光线与实体的空间交点，精确模拟阴影区域。

### 6.4 结果解读
运行脚本后生成的 `dual_cam_layout_3d_flipped.png` 包含两部分：
1.  **左图 (2D Layout)**: 俯视图，用于检查元件排布是否拥挤，以及是否有 LED 被遮挡（红色显示）。
2.  **右图 (3D Model)**: 交互式 3D 视图，展示了摄像头的空间体积、视锥范围（半透明锥体）以及底面的光照强度分布（热力图）。
